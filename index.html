<!DOCTYPE html>
<html>
  <head>
    <!-- Styles for the chips -->
    <style></style>
    <script src="https://cdn.jsdelivr.net/gh/alpinejs/alpine@v2.x.x/dist/alpine.min.js" defer></script>
  </head>

  <body x-data="nameApp()">
    <div id="nameInputs">
      <template x-for="nameEntry in nameEntries" :key="nameEntry.id">
        <div class="nameEntry">
          <input type="text" x-model="nameEntry.name" placeholder="Enter a name..." @input="updateExclusionOptions" />
          <button @click="showExclusionModal(nameEntry)">Set Exclusions</button>
          <span class="exclusions">
            <template x-for="exclusion in nameEntry.exclusions" :key="exclusion">
              <span class="chip">
                <span class="chip-label" x-text="exclusion"></span>
                <span class="chip-close" @click="removeExclusion(nameEntry, exclusion)">X</span>
              </span>
            </template>
          </span>
          <button @click="removeNameInput(nameEntry)">Remove</button>
        </div>
      </template>
    </div>

    <!-- Exclusion Modal -->
    <div x-show="exclusionModalVisible" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 20px; border: 1px solid black">
      <h3>Select Exclusions</h3>
      <div>
        <template x-for="name in availableExclusions">
          <div>
            <input type="checkbox" :value="name" x-model="currentExclusions" />
            <label x-text="name"></label>
          </div>
        </template>
      </div>
      <button @click="saveExclusions()">Save</button>
    </div>

    <button @click="addNameInput()">Add Another Name</button>
    <button @click="assign()">Assign</button>

    <p id="output" x-html="output"></p>

    <script>
      function nameApp() {
        return {
          nameEntries: [{ id: Date.now(), name: "", exclusions: [] }],
          exclusionModalVisible: false,
          availableExclusions: [],
          currentExclusions: [],
          currentNameEntry: null,
          output: "",

          updateExclusionOptions() {
            this.availableExclusions = this.nameEntries.map((entry) => entry.name).filter(Boolean);
          },

          showExclusionModal(nameEntry) {
            this.currentNameEntry = nameEntry;
            this.currentExclusions = [...nameEntry.exclusions];
            this.availableExclusions = this.nameEntries.map((entry) => entry.name).filter((name) => name !== nameEntry.name && Boolean(name)); // Filtering out the current name
            this.exclusionModalVisible = true;
          },

          saveExclusions() {
            this.currentNameEntry.exclusions = [...this.currentExclusions];
            this.exclusionModalVisible = false;
          },

          addNameInput() {
            this.nameEntries.push({ id: Date.now(), name: "", exclusions: [] });
          },

          removeNameInput(nameEntry) {
            const index = this.nameEntries.indexOf(nameEntry);
            if (index > -1) {
              this.nameEntries.splice(index, 1);
            }
            this.updateExclusionOptions();
          },

          removeExclusion(nameEntry, exclusion) {
            const index = nameEntry.exclusions.indexOf(exclusion);
            if (index > -1) {
              nameEntry.exclusions.splice(index, 1);
            }
          },

          assign() {
            let names = this.nameEntries.map((entry) => entry.name).filter(Boolean);
            let exclusions = {};
            this.nameEntries.forEach((entry) => {
              exclusions[entry.name] = entry.exclusions;
            });

            let assignments = this.createAssignments(names, exclusions);
            this.output = assignments.join("<br>");
          },

          createAssignments(names, exclusions) {
            let shuffledNames = [...names].sort(() => Math.random() - 0.5);

            let assignmentsDict = {}; // Dictionary to hold assignments
            let recipients = new Set(); // To keep track of who has been assigned a gift

            for (let i = 0; i < shuffledNames.length; i++) {
              let currentName = shuffledNames[i];
              let nextIndex = (i + 1) % shuffledNames.length;
              let matchedName = shuffledNames[nextIndex];
              let attempts = 0; // Counter to track attempts to find a match

              while (currentName === matchedName || (exclusions[currentName] && exclusions[currentName].includes(matchedName))) {
                nextIndex = (nextIndex + 1) % shuffledNames.length;
                matchedName = shuffledNames[nextIndex];
                attempts++;

                if (attempts >= names.length) {
                  matchedName = "No one"; // Assigning "No one" as the match
                  break; // Exit the loop
                }
              }

              if (matchedName !== "No one") {
                recipients.add(matchedName);
              }

              if (!assignmentsDict[currentName]) {
                assignmentsDict[currentName] = [];
              }
              assignmentsDict[currentName].push(matchedName);
            }

            // Identify the left-out people
            let leftOutPeople = shuffledNames.filter((name) => !recipients.has(name));

            // Shuffle the potential gifters
            let potentialGifters = shuffledNames.filter((name) => name !== "No one");
            potentialGifters.sort(() => Math.random() - 0.5);

            // Assign the left-out people to the shuffled gifters
            leftOutPeople.forEach((person) => {
              let triedGifters = new Set();
              let gifterIndex = Math.floor(Math.random() * potentialGifters.length);
              let gifter = potentialGifters[gifterIndex];

              // Ensure a person isn't matched with themselves and respect exclusions
              while (gifter === person || (exclusions[gifter] && exclusions[gifter].includes(person)) || triedGifters.has(gifter)) {
                triedGifters.add(gifter);

                if (triedGifters.size >= potentialGifters.length) {
                  // We've tried all potential gifters for this person and none are valid
                  gifter = "No one";
                  break;
                }

                gifterIndex = (gifterIndex + 1) % potentialGifters.length;
                gifter = potentialGifters[gifterIndex];
              }

              if (!assignmentsDict[gifter]) {
                assignmentsDict[gifter] = [];
              }
              assignmentsDict[gifter].push(person);
            });

            // Convert the dictionary to a list format for display
            let assignmentsList = [];
            for (let gifter in assignmentsDict) {
              assignmentsList.push(gifter + " -> " + assignmentsDict[gifter].join(", "));
            }

            return assignmentsList;
          }
        };
      }
    </script>
  </body>
</html>
